/*==============================================================*/
/* DBMS name:      ORACLE Version 11g                           */
/* Created on:     14.04.2014 15:21:02                          */
/*==============================================================*/



-- TYPE PACKAGE DECLARATION
CREATE OR REPLACE PACKAGE PDTYPES  
AS
    TYPE REF_CURSOR IS REF CURSOR;
END;

-- INTEGRITY PACKAGE DECLARATION
CREATE OR REPLACE PACKAGE INTEGRITYPACKAGE AS
 PROCEDURE INITNESTLEVEL;
 FUNCTION GETNESTLEVEL RETURN NUMBER;
 PROCEDURE NEXTNESTLEVEL;
 PROCEDURE PREVIOUSNESTLEVEL;
 END INTEGRITYPACKAGE;
/

-- INTEGRITY PACKAGE DEFINITION
CREATE OR REPLACE PACKAGE BODY INTEGRITYPACKAGE AS
 NESTLEVEL NUMBER;

-- PROCEDURE TO INITIALIZE THE TRIGGER NEST LEVEL
 PROCEDURE INITNESTLEVEL IS
 BEGIN
 NESTLEVEL := 0;
 END;


-- FUNCTION TO RETURN THE TRIGGER NEST LEVEL
 FUNCTION GETNESTLEVEL RETURN NUMBER IS
 BEGIN
 IF NESTLEVEL IS NULL THEN
     NESTLEVEL := 0;
 END IF;
 RETURN(NESTLEVEL);
 END;

-- PROCEDURE TO INCREASE THE TRIGGER NEST LEVEL
 PROCEDURE NEXTNESTLEVEL IS
 BEGIN
 IF NESTLEVEL IS NULL THEN
     NESTLEVEL := 0;
 END IF;
 NESTLEVEL := NESTLEVEL + 1;
 END;

-- PROCEDURE TO DECREASE THE TRIGGER NEST LEVEL
 PROCEDURE PREVIOUSNESTLEVEL IS
 BEGIN
 NESTLEVEL := NESTLEVEL - 1;
 END;

 END INTEGRITYPACKAGE;
/


DROP TRIGGER "COMPOUNDDELETETRIGGER_BRANCHES"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_BRANCHES"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_BRANCHES"
/

DROP TRIGGER "TDA_BRANCHES"
/

DROP TRIGGER "TIB_BRANCHES"
/

DROP TRIGGER "TUA_BRANCHES"
/

DROP TRIGGER "TUB_BRANCHES"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_COMMITS"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_COMMITS"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_COMMITS"
/

DROP TRIGGER "TIB_COMMITS"
/

DROP TRIGGER "TUB_COMMITS"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_ESTIMATI"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_ESTIMATI"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_ESTIMATI"
/

DROP TRIGGER "TDA_ESTIMATION_RESULTS"
/

DROP TRIGGER "TIB_ESTIMATION_RESULTS"
/

DROP TRIGGER "TUA_ESTIMATION_RESULTS"
/

DROP TRIGGER "TUB_ESTIMATION_RESULTS"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_INTERNAL"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_INTERNAL"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_INTERNAL"
/

DROP TRIGGER "TDA_INTERNAL_TESTING_RESULTS"
/

DROP TRIGGER "TIB_INTERNAL_TESTING_RESULTS"
/

DROP TRIGGER "TUA_INTERNAL_TESTING_RESULTS"
/

DROP TRIGGER "TUB_INTERNAL_TESTING_RESULTS"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_INTRODUC"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_INTRODUC"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_INTRODUC"
/

DROP TRIGGER "TDA_INTRODUCING_RESULTS"
/

DROP TRIGGER "TUA_INTRODUCING_RESULTS"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_SYSTEM_T"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_SYSTEM_T"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_SYSTEM_T"
/

DROP TRIGGER "TDA_SYSTEM_TESTING_RESULTS"
/

DROP TRIGGER "TIB_SYSTEM_TESTING_RESULTS"
/

DROP TRIGGER "TUA_SYSTEM_TESTING_RESULTS"
/

DROP TRIGGER "TUB_SYSTEM_TESTING_RESULTS"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_UNIT_TES"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_UNIT_TES"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_UNIT_TES"
/

DROP TRIGGER "TDA_UNIT_TESTING_RESULTS"
/

DROP TRIGGER "TIB_UNIT_TESTING_RESULTS"
/

DROP TRIGGER "TUA_UNIT_TESTING_RESULTS"
/

DROP TRIGGER "TUB_UNIT_TESTING_RESULTS"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_IMPLEMEN"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_IMPLEMEN"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_IMPLEMEN"
/

DROP TRIGGER "TDA_IMPLEMENTATION_PLAN"
/

DROP TRIGGER "TUA_IMPLEMENTATION_PLAN"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_PROJECT_"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_PROJECT_"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_PROJECT_"
/

DROP TRIGGER "TIB_PROJECT_ACCESS_PERMISSIONS"
/

DROP TRIGGER "TUB_PROJECT_ACCESS_PERMISSIONS"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_PROJECTS"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_PROJECTS"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_PROJECTS"
/

DROP TRIGGER "TDA_PROJECTS"
/

DROP TRIGGER "TIB_PROJECTS"
/

DROP TRIGGER "TUA_PROJECTS"
/

DROP TRIGGER "TUB_PROJECTS"
/

DROP TRIGGER "COMPOUNDDELETETRIGGER_USERS"
/

DROP TRIGGER "COMPOUNDINSERTTRIGGER_USERS"
/

DROP TRIGGER "COMPOUNDUPDATETRIGGER_USERS"
/

DROP TRIGGER "TDA_USERS"
/

DROP TRIGGER "TUA_USERS"
/

DROP INDEX "BRANCH_FOR_SYSTEM_TESTING_FK"
/

DROP INDEX "BRANCH_FOR_UNIT_TESTING2_FK"
/

DROP INDEX "BRANCH_FOR_RESULTS_FK"
/

DROP INDEX "PROJECT_HAS_BRANCHES_FK"
/

DROP TABLE "BRANCHES" CASCADE CONSTRAINTS
/

DROP INDEX "USER_MAKES_COMMITS_FK"
/

DROP INDEX "BRANCH_HAS_COMMITS_FK"
/

DROP TABLE "COMMITS" CASCADE CONSTRAINTS
/

DROP INDEX "BRANCH_FOR_RESULTS2_FK"
/

DROP INDEX "COMPARE_INTRODUCING_PLAN_FK"
/

DROP INDEX "EVALUTE_INTRODUCING_RESULTS_FK"
/

DROP INDEX "EVALUATES_TEST_RESULTS_FK"
/

DROP TABLE "ESTIMATION_RESULTS" CASCADE CONSTRAINTS
/

DROP INDEX "ANALYSIS_UNIT_TESTING_FK"
/

DROP INDEX "ANALYSIS_SYSTEM_TESTING_FK"
/

DROP TABLE "INTERNAL_TESTING_RESULTS" CASCADE CONSTRAINTS
/

DROP TABLE "INTRODUCING_RESULTS" CASCADE CONSTRAINTS
/

DROP INDEX "BRANCH_FOR_SYSTEM_TESTING2_FK"
/

DROP TABLE "SYSTEM_TESTING_RESULTS" CASCADE CONSTRAINTS
/

DROP INDEX "BRANCH_FOR_UNIT_TESTING_FK"
/

DROP TABLE "UNIT_TESTING_RESULTS" CASCADE CONSTRAINTS
/

DROP TABLE "IMPLEMENTATION_PLAN" CASCADE CONSTRAINTS
/

DROP INDEX "USER_HAS_ACCESS_PERMISSIONS_FK"
/

DROP INDEX "BRANCH_PROVIDES_ACCESS_PERMISS"
/

DROP TABLE "PROJECT_ACCESS_PERMISSIONS" CASCADE CONSTRAINTS
/

DROP INDEX "USER_IS_PROJECT_ADMINISTRATOR_"
/

DROP TABLE "PROJECTS" CASCADE CONSTRAINTS
/

DROP TABLE "USERS" CASCADE CONSTRAINTS
/

/*==============================================================*/
/* Table: "BRANCHES"                                            */
/*==============================================================*/
CREATE TABLE "BRANCHES" 
(
   "PROJECT_ID"         INTEGER              NOT NULL,
   "BRANCH_COMMENT"     CHAR(100),
   "BRANCH_CREATION_TIME" CHAR(30),
   "BRANCH_ID"          INTEGER              NOT NULL,
   "ESTIMATION_NUMBER"  SMALLINT             NOT NULL,
   "UNIT_TESTING_NUMBER" INTEGER              NOT NULL,
   "SYSTEM_TESTING_NUMBER" SMALLINT             NOT NULL,
   "BRANCH_NAME"        CHAR(100),
   CONSTRAINT PK_BRANCHES PRIMARY KEY ("PROJECT_ID", "BRANCH_ID")
)
/

COMMENT ON TABLE "BRANCHES" IS
'Містить інформацію про розгалуження проектів'
/

/*==============================================================*/
/* Index: "PROJECT_HAS_BRANCHES_FK"                             */
/*==============================================================*/
CREATE INDEX "PROJECT_HAS_BRANCHES_FK" ON "BRANCHES" (
   "PROJECT_ID" ASC
)
/

/*==============================================================*/
/* Index: "BRANCH_FOR_RESULTS_FK"                               */
/*==============================================================*/
CREATE INDEX "BRANCH_FOR_RESULTS_FK" ON "BRANCHES" (
   "ESTIMATION_NUMBER" ASC
)
/

/*==============================================================*/
/* Index: "BRANCH_FOR_UNIT_TESTING2_FK"                         */
/*==============================================================*/
CREATE INDEX "BRANCH_FOR_UNIT_TESTING2_FK" ON "BRANCHES" (
   "UNIT_TESTING_NUMBER" ASC
)
/

/*==============================================================*/
/* Index: "BRANCH_FOR_SYSTEM_TESTING_FK"                        */
/*==============================================================*/
CREATE INDEX "BRANCH_FOR_SYSTEM_TESTING_FK" ON "BRANCHES" (
   "SYSTEM_TESTING_NUMBER" ASC
)
/

/*==============================================================*/
/* Table: "COMMITS"                                             */
/*==============================================================*/
CREATE TABLE "COMMITS" 
(
   "PROJECT_ID"         INTEGER              NOT NULL,
   "BRANCH_ID"          INTEGER              NOT NULL,
   "COMMIT_TIME"        CHAR(30)             NOT NULL,
   "COMMIT_ID"          INTEGER              NOT NULL,
   "USER_NAME"          CHAR(100)            NOT NULL,
   "COMMIT_DESCRIPTION" CLOB                 NOT NULL,
   "COMMIT_NAME"        CHAR(100),
   CONSTRAINT PK_COMMITS PRIMARY KEY ("PROJECT_ID", "BRANCH_ID", "COMMIT_ID")
)
/

COMMENT ON TABLE "COMMITS" IS
'Містить інформацію про зміни, внесені до розгалуження проекту'
/

/*==============================================================*/
/* Index: "BRANCH_HAS_COMMITS_FK"                               */
/*==============================================================*/
CREATE INDEX "BRANCH_HAS_COMMITS_FK" ON "COMMITS" (
   "PROJECT_ID" ASC,
   "BRANCH_ID" ASC
)
/

/*==============================================================*/
/* Index: "USER_MAKES_COMMITS_FK"                               */
/*==============================================================*/
CREATE INDEX "USER_MAKES_COMMITS_FK" ON "COMMITS" (
   "USER_NAME" ASC
)
/

/*==============================================================*/
/* Table: "ESTIMATION_RESULTS"                                  */
/*==============================================================*/
CREATE TABLE "ESTIMATION_RESULTS" 
(
   "ESTIMATION_NUMBER"  SMALLINT             NOT NULL,
   "ESTIMATION_DATE"    CHAR(30)             NOT NULL,
   "INTERNAL_RESULTS_NUMBER" INTEGER              NOT NULL,
   "INTRODUCING_RESULT_NUMBER" INTEGER,
   "IMPLEMENTATION_PLAN_NUMBER" INTEGER              NOT NULL,
   "PROJECT_ID"         INTEGER              NOT NULL,
   "BRANCH_ID"          INTEGER              NOT NULL,
   "SUCCESS_PROBABILITY" SMALLINT,
   "EXPECTED_INCOME"    INTEGER,
   "NEED_INTRODUCTION"  SMALLINT,
   CONSTRAINT PK_ESTIMATION_RESULTS PRIMARY KEY ("ESTIMATION_NUMBER")
)
/

/*==============================================================*/
/* Index: "EVALUATES_TEST_RESULTS_FK"                           */
/*==============================================================*/
CREATE INDEX "EVALUATES_TEST_RESULTS_FK" ON "ESTIMATION_RESULTS" (
   "INTERNAL_RESULTS_NUMBER" ASC
)
/

/*==============================================================*/
/* Index: "EVALUTE_INTRODUCING_RESULTS_FK"                      */
/*==============================================================*/
CREATE INDEX "EVALUTE_INTRODUCING_RESULTS_FK" ON "ESTIMATION_RESULTS" (
   "INTRODUCING_RESULT_NUMBER" ASC
)
/

/*==============================================================*/
/* Index: "COMPARE_INTRODUCING_PLAN_FK"                         */
/*==============================================================*/
CREATE INDEX "COMPARE_INTRODUCING_PLAN_FK" ON "ESTIMATION_RESULTS" (
   "IMPLEMENTATION_PLAN_NUMBER" ASC
)
/

/*==============================================================*/
/* Index: "BRANCH_FOR_RESULTS2_FK"                              */
/*==============================================================*/
CREATE INDEX "BRANCH_FOR_RESULTS2_FK" ON "ESTIMATION_RESULTS" (
   "PROJECT_ID" ASC,
   "BRANCH_ID" ASC
)
/

/*==============================================================*/
/* Table: "INTERNAL_TESTING_RESULTS"                            */
/*==============================================================*/
CREATE TABLE "INTERNAL_TESTING_RESULTS" 
(
   "INTERNAL_RESULTS_NUMBER" INTEGER              NOT NULL,
   "INTERNAL_RESULTS_DATE" CHAR(30),
   "SYSTEM_TESTING_NUMBER" SMALLINT,
   "UNIT_TESTING_NUMBER" INTEGER,
   "USER_RATING"        SMALLINT,
   "PERCENT_EFFICIENCY_SOFTWARE" SMALLINT,
   "FIXES_BUGS_PERCENT" SMALLINT,
   "CRITICAL_STRIKE_CHANCE_BUG" SMALLINT,
   "AVAILABILITY_MAJOR_BUGS" SMALLINT,
   CONSTRAINT PK_INTERNAL_TESTING_RESULTS PRIMARY KEY ("INTERNAL_RESULTS_NUMBER")
)
/

/*==============================================================*/
/* Index: "ANALYSIS_SYSTEM_TESTING_FK"                          */
/*==============================================================*/
CREATE INDEX "ANALYSIS_SYSTEM_TESTING_FK" ON "INTERNAL_TESTING_RESULTS" (
   "SYSTEM_TESTING_NUMBER" ASC
)
/

/*==============================================================*/
/* Index: "ANALYSIS_UNIT_TESTING_FK"                            */
/*==============================================================*/
CREATE INDEX "ANALYSIS_UNIT_TESTING_FK" ON "INTERNAL_TESTING_RESULTS" (
   "UNIT_TESTING_NUMBER" ASC
)
/

/*==============================================================*/
/* Table: "INTRODUCING_RESULTS"                                 */
/*==============================================================*/
CREATE TABLE "INTRODUCING_RESULTS" 
(
   "INTRODUCING_RESULT_NUMBER" INTEGER              NOT NULL,
   "INTRODUCING_RESULT_DATE" CHAR(30),
   "TOTAL_BUGS"         INTEGER,
   "TOTAL_USER_ESTIMATION" SMALLINT,
   "FUNDS_SPENT_ON_IMPLEMENTATION" INTEGER,
   "STABILITY"          SMALLINT,
   "PRELIMINARY_INCOME" INTEGER,
   CONSTRAINT PK_INTRODUCING_RESULTS PRIMARY KEY ("INTRODUCING_RESULT_NUMBER")
)
/

/*==============================================================*/
/* Table: "SYSTEM_TESTING_RESULTS"                              */
/*==============================================================*/
CREATE TABLE "SYSTEM_TESTING_RESULTS" 
(
   "SYSTEM_TESTING_NUMBER" SMALLINT             NOT NULL,
   "PROJECT_ID"         INTEGER              NOT NULL,
   "BRANCH_ID"          INTEGER              NOT NULL,
   "SYSTEM_NAME"        CHAR(30),
   "TOTAL_BUGS"         INTEGER,
   "TOTAL_BUG_FIXES"    INTEGER,
   "TESTING_DATE"       CHAR(30),
   "EVALUATION_USABILITY" SMALLINT,
   "EXERCISE_TESTING_EVALUATION" SMALLINT,
   "EVALUATION_UI"      SMALLINT,
   "EVALUATION_COMPATIBILITY" SMALLINT,
   "EVALUATION_SAFETY"  SMALLINT,
   "EVALUATION_PERFORMANCE" SMALLINT,
   CONSTRAINT PK_SYSTEM_TESTING_RESULTS PRIMARY KEY ("SYSTEM_TESTING_NUMBER")
)
/

/*==============================================================*/
/* Index: "BRANCH_FOR_SYSTEM_TESTING2_FK"                       */
/*==============================================================*/
CREATE INDEX "BRANCH_FOR_SYSTEM_TESTING2_FK" ON "SYSTEM_TESTING_RESULTS" (
   "PROJECT_ID" ASC,
   "BRANCH_ID" ASC
)
/

/*==============================================================*/
/* Table: "UNIT_TESTING_RESULTS"                                */
/*==============================================================*/
CREATE TABLE "UNIT_TESTING_RESULTS" 
(
   "UNIT_TESTING_NUMBER" INTEGER              NOT NULL,
   "PROJECT_ID"         INTEGER              NOT NULL,
   "BRANCH_ID"          INTEGER              NOT NULL,
   "SYSTEM_NAME"        CHAR(30),
   "TOTAL_BUGS"         INTEGER,
   "EVALUATION_REGRESSION_TESTING" SMALLINT,
   "MOCK_OBJECT_NUMBER" SMALLINT,
   "COVER_RATIO_UNIT_TESTS" SMALLINT,
   "REPORTED_BUGS_NUMBER" INTEGER,
   "TOTAL_BUG_FIXES"    INTEGER,
   "TESTING_DATE"       INTEGER,
   CONSTRAINT PK_UNIT_TESTING_RESULTS PRIMARY KEY ("UNIT_TESTING_NUMBER")
)
/

/*==============================================================*/
/* Index: "BRANCH_FOR_UNIT_TESTING_FK"                          */
/*==============================================================*/
CREATE INDEX "BRANCH_FOR_UNIT_TESTING_FK" ON "UNIT_TESTING_RESULTS" (
   "PROJECT_ID" ASC,
   "BRANCH_ID" ASC
)
/

/*==============================================================*/
/* Table: "IMPLEMENTATION_PLAN"                                 */
/*==============================================================*/
CREATE TABLE "IMPLEMENTATION_PLAN" 
(
   "IMPLEMENTATION_PLAN_NUMBER" INTEGER              NOT NULL,
   "IMPLEMENTATION_PLAN_NAME" CHAR(30),
   "IMPLEMENTATION_DATE" CHAR(30),
   "EXPECTED_INCOME"    INTEGER,
   "STABILITY"          SMALLINT,
   "TOTAL_BUGS"         INTEGER,
   "TOTAL_USER_ESTIMATION" SMALLINT,
   CONSTRAINT PK_IMPLEMENTATION_PLAN PRIMARY KEY ("IMPLEMENTATION_PLAN_NUMBER")
)
/

/*==============================================================*/
/* Table: "PROJECT_ACCESS_PERMISSIONS"                          */
/*==============================================================*/
CREATE TABLE "PROJECT_ACCESS_PERMISSIONS" 
(
   "PROJECT_ID"         INTEGER              NOT NULL,
   "BRANCH_ID"          INTEGER              NOT NULL,
   "USER_NAME"          CHAR(100)            NOT NULL,
   CONSTRAINT PK_PROJECT_ACCESS_PERMISSIONS PRIMARY KEY ("PROJECT_ID", "BRANCH_ID", "USER_NAME")
)
/

/*==============================================================*/
/* Index: "BRANCH_PROVIDES_ACCESS_PERMISS"                      */
/*==============================================================*/
CREATE INDEX "BRANCH_PROVIDES_ACCESS_PERMISS" ON "PROJECT_ACCESS_PERMISSIONS" (
   "PROJECT_ID" ASC,
   "BRANCH_ID" ASC
)
/

/*==============================================================*/
/* Index: "USER_HAS_ACCESS_PERMISSIONS_FK"                      */
/*==============================================================*/
CREATE INDEX "USER_HAS_ACCESS_PERMISSIONS_FK" ON "PROJECT_ACCESS_PERMISSIONS" (
   "USER_NAME" ASC
)
/

/*==============================================================*/
/* Table: "PROJECTS"                                            */
/*==============================================================*/
CREATE TABLE "PROJECTS" 
(
   "PROJECT_CREATION_TIME" CHAR(30),
   "PROJECT_DESCRIPTION" CHAR(100),
   "PROJECT_ID"         INTEGER              NOT NULL,
   "USER_NAME"          CHAR(100)            NOT NULL,
   "PROJECT_NAME"       CHAR(100),
   CONSTRAINT PK_PROJECTS PRIMARY KEY ("PROJECT_ID")
)
/

/*==============================================================*/
/* Index: "USER_IS_PROJECT_ADMINISTRATOR_"                      */
/*==============================================================*/
CREATE INDEX "USER_IS_PROJECT_ADMINISTRATOR_" ON "PROJECTS" (
   "USER_NAME" ASC
)
/

/*==============================================================*/
/* Table: "USERS"                                               */
/*==============================================================*/
CREATE TABLE "USERS" 
(
   "USER_NAME"          CHAR(100)            NOT NULL,
   CONSTRAINT PK_USERS PRIMARY KEY ("USER_NAME")
)
/

COMMENT ON TABLE "USERS" IS
'Містить інформацію про користувачів системи'
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_BRANCHES"
FOR DELETE ON "BRANCHES" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_BRANCHES"
FOR INSERT ON "BRANCHES" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_BRANCHES"
FOR UPDATE ON "BRANCHES" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TDA_BRANCHES" AFTER DELETE
ON "BRANCHES" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;

BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  DELETE ALL CHILDREN IN ""COMMITS""
    DELETE "COMMITS"
    WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
     AND   "BRANCH_ID" = :OLD."BRANCH_ID";

    --  DELETE ALL CHILDREN IN ""PROJECT_ACCESS_PERMISSIONS""
    DELETE "PROJECT_ACCESS_PERMISSIONS"
    WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
     AND   "BRANCH_ID" = :OLD."BRANCH_ID";

    --  DELETE ALL CHILDREN IN ""ESTIMATION_RESULTS""
    DELETE "ESTIMATION_RESULTS"
    WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
     AND   "BRANCH_ID" = :OLD."BRANCH_ID";

    --  DELETE ALL CHILDREN IN ""UNIT_TESTING_RESULTS""
    DELETE "UNIT_TESTING_RESULTS"
    WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
     AND   "BRANCH_ID" = :OLD."BRANCH_ID";

    --  DELETE ALL CHILDREN IN ""SYSTEM_TESTING_RESULTS""
    DELETE "SYSTEM_TESTING_RESULTS"
    WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
     AND   "BRANCH_ID" = :OLD."BRANCH_ID";

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TIB_BRANCHES" BEFORE INSERT
ON "BRANCHES" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""PROJECTS""
    CURSOR CPK1_"BRANCHES"(VAR_"PROJECT_ID" INTEGER) IS
       SELECT 1
       FROM   "PROJECTS"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""ESTIMATION_RESULTS""
    CURSOR CPK2_"BRANCHES"(VAR_"ESTIMATION_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "ESTIMATION_RESULTS"
       WHERE  "ESTIMATION_NUMBER" = VAR_"ESTIMATION_NUMBER"
        AND   VAR_"ESTIMATION_NUMBER" IS NOT NULL;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""UNIT_TESTING_RESULTS""
    CURSOR CPK3_"BRANCHES"(VAR_"UNIT_TESTING_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "UNIT_TESTING_RESULTS"
       WHERE  "UNIT_TESTING_NUMBER" = VAR_"UNIT_TESTING_NUMBER"
        AND   VAR_"UNIT_TESTING_NUMBER" IS NOT NULL;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""SYSTEM_TESTING_RESULTS""
    CURSOR CPK4_"BRANCHES"(VAR_"SYSTEM_TESTING_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "SYSTEM_TESTING_RESULTS"
       WHERE  "SYSTEM_TESTING_NUMBER" = VAR_"SYSTEM_TESTING_NUMBER"
        AND   VAR_"SYSTEM_TESTING_NUMBER" IS NOT NULL;

BEGIN
    --  PARENT ""PROJECTS"" MUST EXIST WHEN INSERTING A CHILD IN ""BRANCHES""
    IF :NEW."PROJECT_ID" IS NOT NULL THEN
       OPEN  CPK1_"BRANCHES"(:NEW."PROJECT_ID");
       FETCH CPK1_"BRANCHES" INTO DUMMY;
       FOUND := CPK1_"BRANCHES"%FOUND;
       close CPK1_"BRANCHES";
       if not found then
          errno  := -20002;
          errmsg := 'PARENT DOES NOT EXIST IN ""PROJECTS"". CANNOT CREATE CHILD IN ""BRANCHES"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""ESTIMATION_RESULTS"" must exist when inserting a child in ""BRANCHES""
    if :new."ESTIMATION_NUMBER" is not null then
       open  CPK2_"BRANCHES"(:new."ESTIMATION_NUMBER");
       fetch CPK2_"BRANCHES" into dummy;
       found := CPK2_"BRANCHES"%FOUND;
       CLOSE CPK2_"BRANCHES";
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""ESTIMATION_RESULTS"". CANNOT CREATE CHILD IN ""BRANCHES"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;

    --  PARENT ""UNIT_TESTING_RESULTS"" MUST EXIST WHEN INSERTING A CHILD IN ""BRANCHES""
    IF :NEW."UNIT_TESTING_NUMBER" IS NOT NULL THEN
       OPEN  CPK3_"BRANCHES"(:NEW."UNIT_TESTING_NUMBER");
       FETCH CPK3_"BRANCHES" INTO DUMMY;
       FOUND := CPK3_"BRANCHES"%FOUND;
       close CPK3_"BRANCHES";
       if not found then
          errno  := -20002;
          errmsg := 'PARENT DOES NOT EXIST IN ""UNIT_TESTING_RESULTS"". CANNOT CREATE CHILD IN ""BRANCHES"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""SYSTEM_TESTING_RESULTS"" must exist when inserting a child in ""BRANCHES""
    if :new."SYSTEM_TESTING_NUMBER" is not null then
       open  CPK4_"BRANCHES"(:new."SYSTEM_TESTING_NUMBER");
       fetch CPK4_"BRANCHES" into dummy;
       found := CPK4_"BRANCHES"%FOUND;
       CLOSE CPK4_"BRANCHES";
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""SYSTEM_TESTING_RESULTS"". CANNOT CREATE CHILD IN ""BRANCHES"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE TRIGGER "TUA_BRANCHES" AFTER UPDATE
OF "PROJECT_ID",
   "BRANCH_ID",
   "ESTIMATION_NUMBER",
   "UNIT_TESTING_NUMBER",
   "SYSTEM_TESTING_NUMBER"
ON "BRANCHES" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  MODIFY PARENT CODE OF ""BRANCHES"" FOR ALL CHILDREN IN ""COMMITS""
    IF (UPDATING('PROJECT_ID') AND :OLD."PROJECT_ID" != :NEW."PROJECT_ID") OR
       (UPDATING('BRANCH_ID') AND :OLD."BRANCH_ID" != :NEW."BRANCH_ID") THEN
       UPDATE "COMMITS"
        SET   "PROJECT_ID" = :NEW."PROJECT_ID",
              "BRANCH_ID" = :NEW."BRANCH_ID"
       WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
        AND   "BRANCH_ID" = :OLD."BRANCH_ID";
    END IF;

    --  MODIFY PARENT CODE OF ""BRANCHES"" FOR ALL CHILDREN IN ""PROJECT_ACCESS_PERMISSIONS""
    IF (UPDATING('PROJECT_ID') AND :OLD."PROJECT_ID" != :NEW."PROJECT_ID") OR
       (UPDATING('BRANCH_ID') AND :OLD."BRANCH_ID" != :NEW."BRANCH_ID") THEN
       UPDATE "PROJECT_ACCESS_PERMISSIONS"
        SET   "PROJECT_ID" = :NEW."PROJECT_ID",
              "BRANCH_ID" = :NEW."BRANCH_ID"
       WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
        AND   "BRANCH_ID" = :OLD."BRANCH_ID";
    END IF;

    --  MODIFY PARENT CODE OF ""BRANCHES"" FOR ALL CHILDREN IN ""ESTIMATION_RESULTS""
    IF (UPDATING('PROJECT_ID') AND :OLD."PROJECT_ID" != :NEW."PROJECT_ID") OR
       (UPDATING('BRANCH_ID') AND :OLD."BRANCH_ID" != :NEW."BRANCH_ID") THEN
       UPDATE "ESTIMATION_RESULTS"
        SET   "PROJECT_ID" = :NEW."PROJECT_ID",
              "BRANCH_ID" = :NEW."BRANCH_ID"
       WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
        AND   "BRANCH_ID" = :OLD."BRANCH_ID";
    END IF;

    --  MODIFY PARENT CODE OF ""BRANCHES"" FOR ALL CHILDREN IN ""UNIT_TESTING_RESULTS""
    IF (UPDATING('PROJECT_ID') AND :OLD."PROJECT_ID" != :NEW."PROJECT_ID") OR
       (UPDATING('BRANCH_ID') AND :OLD."BRANCH_ID" != :NEW."BRANCH_ID") THEN
       UPDATE "UNIT_TESTING_RESULTS"
        SET   "PROJECT_ID" = :NEW."PROJECT_ID",
              "BRANCH_ID" = :NEW."BRANCH_ID"
       WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
        AND   "BRANCH_ID" = :OLD."BRANCH_ID";
    END IF;

    --  MODIFY PARENT CODE OF ""BRANCHES"" FOR ALL CHILDREN IN ""SYSTEM_TESTING_RESULTS""
    IF (UPDATING('PROJECT_ID') AND :OLD."PROJECT_ID" != :NEW."PROJECT_ID") OR
       (UPDATING('BRANCH_ID') AND :OLD."BRANCH_ID" != :NEW."BRANCH_ID") THEN
       UPDATE "SYSTEM_TESTING_RESULTS"
        SET   "PROJECT_ID" = :NEW."PROJECT_ID",
              "BRANCH_ID" = :NEW."BRANCH_ID"
       WHERE  "PROJECT_ID" = :OLD."PROJECT_ID"
        AND   "BRANCH_ID" = :OLD."BRANCH_ID";
    END IF;

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TUB_BRANCHES" BEFORE UPDATE
OF "PROJECT_ID",
   "BRANCH_ID",
   "ESTIMATION_NUMBER",
   "UNIT_TESTING_NUMBER",
   "SYSTEM_TESTING_NUMBER"
ON "BRANCHES" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    SEQ NUMBER;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""PROJECTS""
    CURSOR CPK1_"BRANCHES"(VAR_"PROJECT_ID" INTEGER) IS
       SELECT 1
       FROM   "PROJECTS"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""ESTIMATION_RESULTS""
    CURSOR CPK2_"BRANCHES"(VAR_"ESTIMATION_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "ESTIMATION_RESULTS"
       WHERE  "ESTIMATION_NUMBER" = VAR_"ESTIMATION_NUMBER"
        AND   VAR_"ESTIMATION_NUMBER" IS NOT NULL;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""UNIT_TESTING_RESULTS""
    CURSOR CPK3_"BRANCHES"(VAR_"UNIT_TESTING_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "UNIT_TESTING_RESULTS"
       WHERE  "UNIT_TESTING_NUMBER" = VAR_"UNIT_TESTING_NUMBER"
        AND   VAR_"UNIT_TESTING_NUMBER" IS NOT NULL;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""SYSTEM_TESTING_RESULTS""
    CURSOR CPK4_"BRANCHES"(VAR_"SYSTEM_TESTING_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "SYSTEM_TESTING_RESULTS"
       WHERE  "SYSTEM_TESTING_NUMBER" = VAR_"SYSTEM_TESTING_NUMBER"
        AND   VAR_"SYSTEM_TESTING_NUMBER" IS NOT NULL;

BEGIN
    SEQ := INTEGRITYPACKAGE.GETNESTLEVEL;
    --  PARENT ""PROJECTS"" MUST EXIST WHEN UPDATING A CHILD IN ""BRANCHES""
    IF (:NEW."PROJECT_ID" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK1_"BRANCHES"(:NEW."PROJECT_ID");
       FETCH CPK1_"BRANCHES" INTO DUMMY;
       FOUND := CPK1_"BRANCHES"%FOUND;
       close CPK1_"BRANCHES";
       if not found then
          errno  := -20003;
          errmsg := 'PARENT DOES NOT EXIST IN ""PROJECTS"". CANNOT UPDATE CHILD IN ""BRANCHES"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""ESTIMATION_RESULTS"" must exist when updating a child in ""BRANCHES""
    if (:new."ESTIMATION_NUMBER" is not null) and (seq = 0) then
       open  CPK2_"BRANCHES"(:new."ESTIMATION_NUMBER");
       fetch CPK2_"BRANCHES" into dummy;
       found := CPK2_"BRANCHES"%FOUND;
       CLOSE CPK2_"BRANCHES";
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""ESTIMATION_RESULTS"". CANNOT UPDATE CHILD IN ""BRANCHES"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;

    --  PARENT ""UNIT_TESTING_RESULTS"" MUST EXIST WHEN UPDATING A CHILD IN ""BRANCHES""
    IF (:NEW."UNIT_TESTING_NUMBER" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK3_"BRANCHES"(:NEW."UNIT_TESTING_NUMBER");
       FETCH CPK3_"BRANCHES" INTO DUMMY;
       FOUND := CPK3_"BRANCHES"%FOUND;
       close CPK3_"BRANCHES";
       if not found then
          errno  := -20003;
          errmsg := 'PARENT DOES NOT EXIST IN ""UNIT_TESTING_RESULTS"". CANNOT UPDATE CHILD IN ""BRANCHES"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""SYSTEM_TESTING_RESULTS"" must exist when updating a child in ""BRANCHES""
    if (:new."SYSTEM_TESTING_NUMBER" is not null) and (seq = 0) then
       open  CPK4_"BRANCHES"(:new."SYSTEM_TESTING_NUMBER");
       fetch CPK4_"BRANCHES" into dummy;
       found := CPK4_"BRANCHES"%FOUND;
       CLOSE CPK4_"BRANCHES";
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""SYSTEM_TESTING_RESULTS"". CANNOT UPDATE CHILD IN ""BRANCHES"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_COMMITS"
FOR DELETE ON "COMMITS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_COMMITS"
FOR INSERT ON "COMMITS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_COMMITS"
FOR UPDATE ON "COMMITS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TIB_COMMITS" BEFORE INSERT
ON "COMMITS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK1_"COMMITS"(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""USERS""
    CURSOR CPK2_"COMMITS"(VAR_"USER_NAME" VARCHAR) IS
       SELECT 1
       FROM   "USERS"
       WHERE  "USER_NAME" = VAR_"USER_NAME"
        AND   VAR_"USER_NAME" IS NOT NULL;

BEGIN
    --  PARENT ""BRANCHES"" MUST EXIST WHEN INSERTING A CHILD IN ""COMMITS""
    IF :NEW."PROJECT_ID" IS NOT NULL AND
       :NEW."BRANCH_ID" IS NOT NULL THEN
       OPEN  CPK1_"COMMITS"(:NEW."PROJECT_ID",
                      :NEW."BRANCH_ID");
       FETCH CPK1_"COMMITS" INTO DUMMY;
       FOUND := CPK1_"COMMITS"%FOUND;
       close CPK1_"COMMITS";
       if not found then
          errno  := -20002;
          errmsg := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT CREATE CHILD IN ""COMMITS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""USERS"" must exist when inserting a child in ""COMMITS""
    if :new."USER_NAME" is not null then
       open  CPK2_"COMMITS"(:new."USER_NAME");
       fetch CPK2_"COMMITS" into dummy;
       found := CPK2_"COMMITS"%FOUND;
       CLOSE CPK2_"COMMITS";
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""USERS"". CANNOT CREATE CHILD IN ""COMMITS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE TRIGGER "TUB_COMMITS" BEFORE UPDATE
OF "PROJECT_ID",
   "BRANCH_ID",
   "COMMIT_ID",
   "USER_NAME"
ON "COMMITS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    SEQ NUMBER;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK1_"COMMITS"(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""USERS""
    CURSOR CPK2_"COMMITS"(VAR_"USER_NAME" VARCHAR) IS
       SELECT 1
       FROM   "USERS"
       WHERE  "USER_NAME" = VAR_"USER_NAME"
        AND   VAR_"USER_NAME" IS NOT NULL;

BEGIN
    SEQ := INTEGRITYPACKAGE.GETNESTLEVEL;
    --  PARENT ""BRANCHES"" MUST EXIST WHEN UPDATING A CHILD IN ""COMMITS""
    IF (:NEW."PROJECT_ID" IS NOT NULL) AND
       (:NEW."BRANCH_ID" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK1_"COMMITS"(:NEW."PROJECT_ID",
                      :NEW."BRANCH_ID");
       FETCH CPK1_"COMMITS" INTO DUMMY;
       FOUND := CPK1_"COMMITS"%FOUND;
       close CPK1_"COMMITS";
       if not found then
          errno  := -20003;
          errmsg := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT UPDATE CHILD IN ""COMMITS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""USERS"" must exist when updating a child in ""COMMITS""
    if (:new."USER_NAME" is not null) and (seq = 0) then
       open  CPK2_"COMMITS"(:new."USER_NAME");
       fetch CPK2_"COMMITS" into dummy;
       found := CPK2_"COMMITS"%FOUND;
       CLOSE CPK2_"COMMITS";
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""USERS"". CANNOT UPDATE CHILD IN ""COMMITS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_ESTIMATI"
FOR DELETE ON "ESTIMATION_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_ESTIMATI"
FOR INSERT ON "ESTIMATION_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_ESTIMATI"
FOR UPDATE ON "ESTIMATION_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TDA_ESTIMATION_RESULTS" AFTER DELETE
ON "ESTIMATION_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;

BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  DELETE ALL CHILDREN IN ""BRANCHES""
    DELETE "BRANCHES"
    WHERE  "ESTIMATION_NUMBER" = :OLD."ESTIMATION_NUMBER";

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TIB_ESTIMATION_RESULTS" BEFORE INSERT
ON "ESTIMATION_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""INTERNAL_TESTING_RESULTS""
    CURSOR CPK1_"ESTIMATION_RESULTS"(VAR_"INTERNAL_RESULTS_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "INTERNAL_TESTING_RESULTS"
       WHERE  "INTERNAL_RESULTS_NUMBER" = VAR_"INTERNAL_RESULTS_NUMBER"
        AND   VAR_"INTERNAL_RESULTS_NUMBER" IS NOT NULL;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""INTRODUCING_RESULTS""
    CURSOR CPK2_"ESTIMATION_RESULTS"(VAR_"INTRODUCING_RESULT_NUMBER INTEGER) IS
       SELECT 1
       FROM   "INTRODUCING_RESULTS"
       WHERE  "INTRODUCING_RESULT_NUMBER" = VAR_"INTRODUCING_RESULT_NUMBER
        AND   VAR_"INTRODUCING_RESULT_NUMBER IS NOT NULL;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""IMPLEMENTATION_PLAN""
    CURSOR CPK3_"ESTIMATION_RESULTS"(VAR_"IMPLEMENTATION_PLAN_NUMBE INTEGER) IS
       SELECT 1
       FROM   "IMPLEMENTATION_PLAN"
       WHERE  "IMPLEMENTATION_PLAN_NUMBER" = VAR_"IMPLEMENTATION_PLAN_NUMBE
        AND   VAR_"IMPLEMENTATION_PLAN_NUMBE IS NOT NULL;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK4_"ESTIMATION_RESULTS"(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;

BEGIN
    --  PARENT ""INTERNAL_TESTING_RESULTS"" MUST EXIST WHEN INSERTING A CHILD IN ""ESTIMATION_RESULTS""
    IF :NEW."INTERNAL_RESULTS_NUMBER" IS NOT NULL THEN
       OPEN  CPK1_"ESTIMATION_RESULTS"(:NEW."INTERNAL_RESULTS_NUMBER");
       FETCH CPK1_"ESTIMATION_RESULTS" INTO DUMMY;
       FOUND := CPK1_"ESTIMATION_RESULTS"%FOUND;
       close CPK1_"ESTIMATION_RESULTS";
       if not found then
          errno  := -20002;
          errmsg := 'PARENT DOES NOT EXIST IN ""INTERNAL_TESTING_RESULTS"". CANNOT CREATE CHILD IN ""ESTIMATION_RESULTS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""INTRODUCING_RESULTS"" must exist when inserting a child in ""ESTIMATION_RESULTS""
    if :new."INTRODUCING_RESULT_NUMBER" is not null then
       open  CPK2_"ESTIMATION_RESULTS"(:new."INTRODUCING_RESULT_NUMBER");
       fetch CPK2_"ESTIMATION_RESULTS" into dummy;
       found := CPK2_"ESTIMATION_RESULTS"%FOUND;
       CLOSE CPK2_"ESTIMATION_RESULTS";
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""INTRODUCING_RESULTS"". CANNOT CREATE CHILD IN ""ESTIMATION_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;

    --  PARENT ""IMPLEMENTATION_PLAN"" MUST EXIST WHEN INSERTING A CHILD IN ""ESTIMATION_RESULTS""
    IF :NEW."IMPLEMENTATION_PLAN_NUMBER" IS NOT NULL THEN
       OPEN  CPK3_"ESTIMATION_RESULTS"(:NEW."IMPLEMENTATION_PLAN_NUMBER");
       FETCH CPK3_"ESTIMATION_RESULTS" INTO DUMMY;
       FOUND := CPK3_"ESTIMATION_RESULTS"%FOUND;
       close CPK3_"ESTIMATION_RESULTS";
       if not found then
          errno  := -20002;
          errmsg := 'PARENT DOES NOT EXIST IN ""IMPLEMENTATION_PLAN"". CANNOT CREATE CHILD IN ""ESTIMATION_RESULTS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""BRANCHES"" must exist when inserting a child in ""ESTIMATION_RESULTS""
    if :new."PROJECT_ID" is not null and
       :new."BRANCH_ID" is not null then
       open  CPK4_"ESTIMATION_RESULTS"(:new."PROJECT_ID",
                      :new."BRANCH_ID");
       fetch CPK4_"ESTIMATION_RESULTS" into dummy;
       found := CPK4_"ESTIMATION_RESULTS"%FOUND;
       CLOSE CPK4_"ESTIMATION_RESULTS";
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT CREATE CHILD IN ""ESTIMATION_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE TRIGGER "TUA_ESTIMATION_RESULTS" AFTER UPDATE
OF "ESTIMATION_NUMBER",
   "INTERNAL_RESULTS_NUMBER",
   "INTRODUCING_RESULT_NUMBER",
   "IMPLEMENTATION_PLAN_NUMBER",
   "PROJECT_ID",
   "BRANCH_ID"
ON "ESTIMATION_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  MODIFY PARENT CODE OF ""ESTIMATION_RESULTS"" FOR ALL CHILDREN IN ""BRANCHES""
    IF (UPDATING('ESTIMATION_NUMBER') AND :OLD."ESTIMATION_NUMBER" != :NEW."ESTIMATION_NUMBER") THEN
       UPDATE "BRANCHES"
        SET   "ESTIMATION_NUMBER" = :NEW."ESTIMATION_NUMBER"
       WHERE  "ESTIMATION_NUMBER" = :OLD."ESTIMATION_NUMBER";
    END IF;

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TUB_ESTIMATION_RESULTS" BEFORE UPDATE
OF "ESTIMATION_NUMBER",
   "INTERNAL_RESULTS_NUMBER",
   "INTRODUCING_RESULT_NUMBER",
   "IMPLEMENTATION_PLAN_NUMBER",
   "PROJECT_ID",
   "BRANCH_ID"
ON "ESTIMATION_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    SEQ NUMBER;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""INTERNAL_TESTING_RESULTS""
    CURSOR CPK1_"ESTIMATION_RESULTS"(VAR_"INTERNAL_RESULTS_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "INTERNAL_TESTING_RESULTS"
       WHERE  "INTERNAL_RESULTS_NUMBER" = VAR_"INTERNAL_RESULTS_NUMBER"
        AND   VAR_"INTERNAL_RESULTS_NUMBER" IS NOT NULL;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""INTRODUCING_RESULTS""
    CURSOR CPK2_"ESTIMATION_RESULTS"(VAR_"INTRODUCING_RESULT_NUMBER INTEGER) IS
       SELECT 1
       FROM   "INTRODUCING_RESULTS"
       WHERE  "INTRODUCING_RESULT_NUMBER" = VAR_"INTRODUCING_RESULT_NUMBER
        AND   VAR_"INTRODUCING_RESULT_NUMBER IS NOT NULL;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""IMPLEMENTATION_PLAN""
    CURSOR CPK3_"ESTIMATION_RESULTS"(VAR_"IMPLEMENTATION_PLAN_NUMBE INTEGER) IS
       SELECT 1
       FROM   "IMPLEMENTATION_PLAN"
       WHERE  "IMPLEMENTATION_PLAN_NUMBER" = VAR_"IMPLEMENTATION_PLAN_NUMBE
        AND   VAR_"IMPLEMENTATION_PLAN_NUMBE IS NOT NULL;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK4_"ESTIMATION_RESULTS"(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;

BEGIN
    SEQ := INTEGRITYPACKAGE.GETNESTLEVEL;
    --  PARENT ""INTERNAL_TESTING_RESULTS"" MUST EXIST WHEN UPDATING A CHILD IN ""ESTIMATION_RESULTS""
    IF (:NEW."INTERNAL_RESULTS_NUMBER" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK1_"ESTIMATION_RESULTS"(:NEW."INTERNAL_RESULTS_NUMBER");
       FETCH CPK1_"ESTIMATION_RESULTS" INTO DUMMY;
       FOUND := CPK1_"ESTIMATION_RESULTS"%FOUND;
       close CPK1_"ESTIMATION_RESULTS";
       if not found then
          errno  := -20003;
          errmsg := 'PARENT DOES NOT EXIST IN ""INTERNAL_TESTING_RESULTS"". CANNOT UPDATE CHILD IN ""ESTIMATION_RESULTS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""INTRODUCING_RESULTS"" must exist when updating a child in ""ESTIMATION_RESULTS""
    if (:new."INTRODUCING_RESULT_NUMBER" is not null) and (seq = 0) then
       open  CPK2_"ESTIMATION_RESULTS"(:new."INTRODUCING_RESULT_NUMBER");
       fetch CPK2_"ESTIMATION_RESULTS" into dummy;
       found := CPK2_"ESTIMATION_RESULTS"%FOUND;
       CLOSE CPK2_"ESTIMATION_RESULTS";
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""INTRODUCING_RESULTS"". CANNOT UPDATE CHILD IN ""ESTIMATION_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;

    --  PARENT ""IMPLEMENTATION_PLAN"" MUST EXIST WHEN UPDATING A CHILD IN ""ESTIMATION_RESULTS""
    IF (:NEW."IMPLEMENTATION_PLAN_NUMBER" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK3_"ESTIMATION_RESULTS"(:NEW."IMPLEMENTATION_PLAN_NUMBER");
       FETCH CPK3_"ESTIMATION_RESULTS" INTO DUMMY;
       FOUND := CPK3_"ESTIMATION_RESULTS"%FOUND;
       close CPK3_"ESTIMATION_RESULTS";
       if not found then
          errno  := -20003;
          errmsg := 'PARENT DOES NOT EXIST IN ""IMPLEMENTATION_PLAN"". CANNOT UPDATE CHILD IN ""ESTIMATION_RESULTS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""BRANCHES"" must exist when updating a child in ""ESTIMATION_RESULTS""
    if (:new."PROJECT_ID" is not null) and
       (:new."BRANCH_ID" is not null) and (seq = 0) then
       open  CPK4_"ESTIMATION_RESULTS"(:new."PROJECT_ID",
                      :new."BRANCH_ID");
       fetch CPK4_"ESTIMATION_RESULTS" into dummy;
       found := CPK4_"ESTIMATION_RESULTS"%FOUND;
       CLOSE CPK4_"ESTIMATION_RESULTS";
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT UPDATE CHILD IN ""ESTIMATION_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_INTERNAL"
FOR DELETE ON "INTERNAL_TESTING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_INTERNAL"
FOR INSERT ON "INTERNAL_TESTING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_INTERNAL"
FOR UPDATE ON "INTERNAL_TESTING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TDA_INTERNAL_TESTING_RESULTS" AFTER DELETE
ON "INTERNAL_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;

BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  DELETE ALL CHILDREN IN ""ESTIMATION_RESULTS""
    DELETE "ESTIMATION_RESULTS"
    WHERE  "INTERNAL_RESULTS_NUMBER" = :OLD."INTERNAL_RESULTS_NUMBER";

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TIB_INTERNAL_TESTING_RESULTS" BEFORE INSERT
ON "INTERNAL_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""SYSTEM_TESTING_RESULTS""
    CURSOR CPK1_"INTERNAL_TESTING_RESULTS(VAR_"SYSTEM_TESTING_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "SYSTEM_TESTING_RESULTS"
       WHERE  "SYSTEM_TESTING_NUMBER" = VAR_"SYSTEM_TESTING_NUMBER"
        AND   VAR_"SYSTEM_TESTING_NUMBER" IS NOT NULL;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""UNIT_TESTING_RESULTS""
    CURSOR CPK2_"INTERNAL_TESTING_RESULTS(VAR_"UNIT_TESTING_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "UNIT_TESTING_RESULTS"
       WHERE  "UNIT_TESTING_NUMBER" = VAR_"UNIT_TESTING_NUMBER"
        AND   VAR_"UNIT_TESTING_NUMBER" IS NOT NULL;

BEGIN
    --  PARENT ""SYSTEM_TESTING_RESULTS"" MUST EXIST WHEN INSERTING A CHILD IN ""INTERNAL_TESTING_RESULTS""
    IF :NEW."SYSTEM_TESTING_NUMBER" IS NOT NULL THEN
       OPEN  CPK1_"INTERNAL_TESTING_RESULTS(:NEW."SYSTEM_TESTING_NUMBER");
       FETCH CPK1_"INTERNAL_TESTING_RESULTS INTO DUMMY;
       FOUND := CPK1_"INTERNAL_TESTING_RESULTS%FOUND;
       close CPK1_"INTERNAL_TESTING_RESULTS;
       if not found then
          errno  := -20002;
          errmsg := 'PARENT DOES NOT EXIST IN ""SYSTEM_TESTING_RESULTS"". CANNOT CREATE CHILD IN ""INTERNAL_TESTING_RESULTS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""UNIT_TESTING_RESULTS"" must exist when inserting a child in ""INTERNAL_TESTING_RESULTS""
    if :new."UNIT_TESTING_NUMBER" is not null then
       open  CPK2_"INTERNAL_TESTING_RESULTS(:new."UNIT_TESTING_NUMBER");
       fetch CPK2_"INTERNAL_TESTING_RESULTS into dummy;
       found := CPK2_"INTERNAL_TESTING_RESULTS%FOUND;
       CLOSE CPK2_"INTERNAL_TESTING_RESULTS;
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""UNIT_TESTING_RESULTS"". CANNOT CREATE CHILD IN ""INTERNAL_TESTING_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE TRIGGER "TUA_INTERNAL_TESTING_RESULTS" AFTER UPDATE
OF "INTERNAL_RESULTS_NUMBER",
   "SYSTEM_TESTING_NUMBER",
   "UNIT_TESTING_NUMBER"
ON "INTERNAL_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  MODIFY PARENT CODE OF ""INTERNAL_TESTING_RESULTS"" FOR ALL CHILDREN IN ""ESTIMATION_RESULTS""
    IF (UPDATING('INTERNAL_RESULTS_NUMBER') AND :OLD."INTERNAL_RESULTS_NUMBER" != :NEW."INTERNAL_RESULTS_NUMBER") THEN
       UPDATE "ESTIMATION_RESULTS"
        SET   "INTERNAL_RESULTS_NUMBER" = :NEW."INTERNAL_RESULTS_NUMBER"
       WHERE  "INTERNAL_RESULTS_NUMBER" = :OLD."INTERNAL_RESULTS_NUMBER";
    END IF;

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TUB_INTERNAL_TESTING_RESULTS" BEFORE UPDATE
OF "INTERNAL_RESULTS_NUMBER",
   "SYSTEM_TESTING_NUMBER",
   "UNIT_TESTING_NUMBER"
ON "INTERNAL_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    SEQ NUMBER;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""SYSTEM_TESTING_RESULTS""
    CURSOR CPK1_"INTERNAL_TESTING_RESULTS(VAR_"SYSTEM_TESTING_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "SYSTEM_TESTING_RESULTS"
       WHERE  "SYSTEM_TESTING_NUMBER" = VAR_"SYSTEM_TESTING_NUMBER"
        AND   VAR_"SYSTEM_TESTING_NUMBER" IS NOT NULL;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""UNIT_TESTING_RESULTS""
    CURSOR CPK2_"INTERNAL_TESTING_RESULTS(VAR_"UNIT_TESTING_NUMBER" INTEGER) IS
       SELECT 1
       FROM   "UNIT_TESTING_RESULTS"
       WHERE  "UNIT_TESTING_NUMBER" = VAR_"UNIT_TESTING_NUMBER"
        AND   VAR_"UNIT_TESTING_NUMBER" IS NOT NULL;

BEGIN
    SEQ := INTEGRITYPACKAGE.GETNESTLEVEL;
    --  PARENT ""SYSTEM_TESTING_RESULTS"" MUST EXIST WHEN UPDATING A CHILD IN ""INTERNAL_TESTING_RESULTS""
    IF (:NEW."SYSTEM_TESTING_NUMBER" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK1_"INTERNAL_TESTING_RESULTS(:NEW."SYSTEM_TESTING_NUMBER");
       FETCH CPK1_"INTERNAL_TESTING_RESULTS INTO DUMMY;
       FOUND := CPK1_"INTERNAL_TESTING_RESULTS%FOUND;
       close CPK1_"INTERNAL_TESTING_RESULTS;
       if not found then
          errno  := -20003;
          errmsg := 'PARENT DOES NOT EXIST IN ""SYSTEM_TESTING_RESULTS"". CANNOT UPDATE CHILD IN ""INTERNAL_TESTING_RESULTS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""UNIT_TESTING_RESULTS"" must exist when updating a child in ""INTERNAL_TESTING_RESULTS""
    if (:new."UNIT_TESTING_NUMBER" is not null) and (seq = 0) then
       open  CPK2_"INTERNAL_TESTING_RESULTS(:new."UNIT_TESTING_NUMBER");
       fetch CPK2_"INTERNAL_TESTING_RESULTS into dummy;
       found := CPK2_"INTERNAL_TESTING_RESULTS%FOUND;
       CLOSE CPK2_"INTERNAL_TESTING_RESULTS;
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""UNIT_TESTING_RESULTS"". CANNOT UPDATE CHILD IN ""INTERNAL_TESTING_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_INTRODUC"
FOR DELETE ON "INTRODUCING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_INTRODUC"
FOR INSERT ON "INTRODUCING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_INTRODUC"
FOR UPDATE ON "INTRODUCING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TDA_INTRODUCING_RESULTS" AFTER DELETE
ON "INTRODUCING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;

BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  DELETE ALL CHILDREN IN ""ESTIMATION_RESULTS""
    DELETE "ESTIMATION_RESULTS"
    WHERE  "INTRODUCING_RESULT_NUMBER" = :OLD."INTRODUCING_RESULT_NUMBER";

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TUA_INTRODUCING_RESULTS" AFTER UPDATE
OF "INTRODUCING_RESULT_NUMBER"
ON "INTRODUCING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  MODIFY PARENT CODE OF ""INTRODUCING_RESULTS"" FOR ALL CHILDREN IN ""ESTIMATION_RESULTS""
    IF (UPDATING('INTRODUCING_RESULT_NUMBER') AND :OLD."INTRODUCING_RESULT_NUMBER" != :NEW."INTRODUCING_RESULT_NUMBER") THEN
       UPDATE "ESTIMATION_RESULTS"
        SET   "INTRODUCING_RESULT_NUMBER" = :NEW."INTRODUCING_RESULT_NUMBER"
       WHERE  "INTRODUCING_RESULT_NUMBER" = :OLD."INTRODUCING_RESULT_NUMBER";
    END IF;

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_SYSTEM_T"
FOR DELETE ON "SYSTEM_TESTING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_SYSTEM_T"
FOR INSERT ON "SYSTEM_TESTING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_SYSTEM_T"
FOR UPDATE ON "SYSTEM_TESTING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TDA_SYSTEM_TESTING_RESULTS" AFTER DELETE
ON "SYSTEM_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;

BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  DELETE ALL CHILDREN IN ""INTERNAL_TESTING_RESULTS""
    DELETE "INTERNAL_TESTING_RESULTS"
    WHERE  "SYSTEM_TESTING_NUMBER" = :OLD."SYSTEM_TESTING_NUMBER";

    --  DELETE ALL CHILDREN IN ""BRANCHES""
    DELETE "BRANCHES"
    WHERE  "SYSTEM_TESTING_NUMBER" = :OLD."SYSTEM_TESTING_NUMBER";

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TIB_SYSTEM_TESTING_RESULTS" BEFORE INSERT
ON "SYSTEM_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK1_"SYSTEM_TESTING_RESULTS"(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;

BEGIN
    --  PARENT ""BRANCHES"" MUST EXIST WHEN INSERTING A CHILD IN ""SYSTEM_TESTING_RESULTS""
    IF :NEW."PROJECT_ID" IS NOT NULL AND
       :NEW."BRANCH_ID" IS NOT NULL THEN
       OPEN  CPK1_"SYSTEM_TESTING_RESULTS"(:NEW."PROJECT_ID",
                      :NEW."BRANCH_ID");
       FETCH CPK1_"SYSTEM_TESTING_RESULTS" INTO DUMMY;
       FOUND := CPK1_"SYSTEM_TESTING_RESULTS"%FOUND;
       CLOSE CPK1_"SYSTEM_TESTING_RESULTS";
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT CREATE CHILD IN ""SYSTEM_TESTING_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE TRIGGER "TUA_SYSTEM_TESTING_RESULTS" AFTER UPDATE
OF "SYSTEM_TESTING_NUMBER",
   "PROJECT_ID",
   "BRANCH_ID"
ON "SYSTEM_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  MODIFY PARENT CODE OF ""SYSTEM_TESTING_RESULTS"" FOR ALL CHILDREN IN ""INTERNAL_TESTING_RESULTS""
    IF (UPDATING('SYSTEM_TESTING_NUMBER') AND :OLD."SYSTEM_TESTING_NUMBER" != :NEW."SYSTEM_TESTING_NUMBER") THEN
       UPDATE "INTERNAL_TESTING_RESULTS"
        SET   "SYSTEM_TESTING_NUMBER" = :NEW."SYSTEM_TESTING_NUMBER"
       WHERE  "SYSTEM_TESTING_NUMBER" = :OLD."SYSTEM_TESTING_NUMBER";
    END IF;

    --  MODIFY PARENT CODE OF ""SYSTEM_TESTING_RESULTS"" FOR ALL CHILDREN IN ""BRANCHES""
    IF (UPDATING('SYSTEM_TESTING_NUMBER') AND :OLD."SYSTEM_TESTING_NUMBER" != :NEW."SYSTEM_TESTING_NUMBER") THEN
       UPDATE "BRANCHES"
        SET   "SYSTEM_TESTING_NUMBER" = :NEW."SYSTEM_TESTING_NUMBER"
       WHERE  "SYSTEM_TESTING_NUMBER" = :OLD."SYSTEM_TESTING_NUMBER";
    END IF;

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TUB_SYSTEM_TESTING_RESULTS" BEFORE UPDATE
OF "SYSTEM_TESTING_NUMBER",
   "PROJECT_ID",
   "BRANCH_ID"
ON "SYSTEM_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    SEQ NUMBER;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK1_"SYSTEM_TESTING_RESULTS"(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;

BEGIN
    SEQ := INTEGRITYPACKAGE.GETNESTLEVEL;
    --  PARENT ""BRANCHES"" MUST EXIST WHEN UPDATING A CHILD IN ""SYSTEM_TESTING_RESULTS""
    IF (:NEW."PROJECT_ID" IS NOT NULL) AND
       (:NEW."BRANCH_ID" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK1_"SYSTEM_TESTING_RESULTS"(:NEW."PROJECT_ID",
                      :NEW."BRANCH_ID");
       FETCH CPK1_"SYSTEM_TESTING_RESULTS" INTO DUMMY;
       FOUND := CPK1_"SYSTEM_TESTING_RESULTS"%FOUND;
       CLOSE CPK1_"SYSTEM_TESTING_RESULTS";
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT UPDATE CHILD IN ""SYSTEM_TESTING_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_UNIT_TES"
FOR DELETE ON "UNIT_TESTING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_UNIT_TES"
FOR INSERT ON "UNIT_TESTING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_UNIT_TES"
FOR UPDATE ON "UNIT_TESTING_RESULTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TDA_UNIT_TESTING_RESULTS" AFTER DELETE
ON "UNIT_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;

BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  DELETE ALL CHILDREN IN ""INTERNAL_TESTING_RESULTS""
    DELETE "INTERNAL_TESTING_RESULTS"
    WHERE  "UNIT_TESTING_NUMBER" = :OLD."UNIT_TESTING_NUMBER";

    --  DELETE ALL CHILDREN IN ""BRANCHES""
    DELETE "BRANCHES"
    WHERE  "UNIT_TESTING_NUMBER" = :OLD."UNIT_TESTING_NUMBER";

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TIB_UNIT_TESTING_RESULTS" BEFORE INSERT
ON "UNIT_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK1_"UNIT_TESTING_RESULTS"(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;

BEGIN
    --  PARENT ""BRANCHES"" MUST EXIST WHEN INSERTING A CHILD IN ""UNIT_TESTING_RESULTS""
    IF :NEW."PROJECT_ID" IS NOT NULL AND
       :NEW."BRANCH_ID" IS NOT NULL THEN
       OPEN  CPK1_"UNIT_TESTING_RESULTS"(:NEW."PROJECT_ID",
                      :NEW."BRANCH_ID");
       FETCH CPK1_"UNIT_TESTING_RESULTS" INTO DUMMY;
       FOUND := CPK1_"UNIT_TESTING_RESULTS"%FOUND;
       CLOSE CPK1_"UNIT_TESTING_RESULTS";
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT CREATE CHILD IN ""UNIT_TESTING_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE TRIGGER "TUA_UNIT_TESTING_RESULTS" AFTER UPDATE
OF "UNIT_TESTING_NUMBER",
   "PROJECT_ID",
   "BRANCH_ID"
ON "UNIT_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  MODIFY PARENT CODE OF ""UNIT_TESTING_RESULTS"" FOR ALL CHILDREN IN ""INTERNAL_TESTING_RESULTS""
    IF (UPDATING('UNIT_TESTING_NUMBER') AND :OLD."UNIT_TESTING_NUMBER" != :NEW."UNIT_TESTING_NUMBER") THEN
       UPDATE "INTERNAL_TESTING_RESULTS"
        SET   "UNIT_TESTING_NUMBER" = :NEW."UNIT_TESTING_NUMBER"
       WHERE  "UNIT_TESTING_NUMBER" = :OLD."UNIT_TESTING_NUMBER";
    END IF;

    --  MODIFY PARENT CODE OF ""UNIT_TESTING_RESULTS"" FOR ALL CHILDREN IN ""BRANCHES""
    IF (UPDATING('UNIT_TESTING_NUMBER') AND :OLD."UNIT_TESTING_NUMBER" != :NEW."UNIT_TESTING_NUMBER") THEN
       UPDATE "BRANCHES"
        SET   "UNIT_TESTING_NUMBER" = :NEW."UNIT_TESTING_NUMBER"
       WHERE  "UNIT_TESTING_NUMBER" = :OLD."UNIT_TESTING_NUMBER";
    END IF;

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TUB_UNIT_TESTING_RESULTS" BEFORE UPDATE
OF "UNIT_TESTING_NUMBER",
   "PROJECT_ID",
   "BRANCH_ID"
ON "UNIT_TESTING_RESULTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    SEQ NUMBER;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK1_"UNIT_TESTING_RESULTS"(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;

BEGIN
    SEQ := INTEGRITYPACKAGE.GETNESTLEVEL;
    --  PARENT ""BRANCHES"" MUST EXIST WHEN UPDATING A CHILD IN ""UNIT_TESTING_RESULTS""
    IF (:NEW."PROJECT_ID" IS NOT NULL) AND
       (:NEW."BRANCH_ID" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK1_"UNIT_TESTING_RESULTS"(:NEW."PROJECT_ID",
                      :NEW."BRANCH_ID");
       FETCH CPK1_"UNIT_TESTING_RESULTS" INTO DUMMY;
       FOUND := CPK1_"UNIT_TESTING_RESULTS"%FOUND;
       CLOSE CPK1_"UNIT_TESTING_RESULTS";
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT UPDATE CHILD IN ""UNIT_TESTING_RESULTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_IMPLEMEN"
FOR DELETE ON "IMPLEMENTATION_PLAN" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_IMPLEMEN"
FOR INSERT ON "IMPLEMENTATION_PLAN" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_IMPLEMEN"
FOR UPDATE ON "IMPLEMENTATION_PLAN" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TDA_IMPLEMENTATION_PLAN" AFTER DELETE
ON "IMPLEMENTATION_PLAN" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;

BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  DELETE ALL CHILDREN IN ""ESTIMATION_RESULTS""
    DELETE "ESTIMATION_RESULTS"
    WHERE  "IMPLEMENTATION_PLAN_NUMBER" = :OLD."IMPLEMENTATION_PLAN_NUMBER";

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TUA_IMPLEMENTATION_PLAN" AFTER UPDATE
OF "IMPLEMENTATION_PLAN_NUMBER"
ON "IMPLEMENTATION_PLAN" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  MODIFY PARENT CODE OF ""IMPLEMENTATION_PLAN"" FOR ALL CHILDREN IN ""ESTIMATION_RESULTS""
    IF (UPDATING('IMPLEMENTATION_PLAN_NUMBER') AND :OLD."IMPLEMENTATION_PLAN_NUMBER" != :NEW."IMPLEMENTATION_PLAN_NUMBER") THEN
       UPDATE "ESTIMATION_RESULTS"
        SET   "IMPLEMENTATION_PLAN_NUMBER" = :NEW."IMPLEMENTATION_PLAN_NUMBER"
       WHERE  "IMPLEMENTATION_PLAN_NUMBER" = :OLD."IMPLEMENTATION_PLAN_NUMBER";
    END IF;

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_PROJECT_"
FOR DELETE ON "PROJECT_ACCESS_PERMISSIONS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_PROJECT_"
FOR INSERT ON "PROJECT_ACCESS_PERMISSIONS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_PROJECT_"
FOR UPDATE ON "PROJECT_ACCESS_PERMISSIONS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TIB_PROJECT_ACCESS_PERMISSIONS" BEFORE INSERT
ON "PROJECT_ACCESS_PERMISSIONS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK1_"PROJECT_ACCESS_PERMISSIO(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""USERS""
    CURSOR CPK2_"PROJECT_ACCESS_PERMISSIO(VAR_"USER_NAME" VARCHAR) IS
       SELECT 1
       FROM   "USERS"
       WHERE  "USER_NAME" = VAR_"USER_NAME"
        AND   VAR_"USER_NAME" IS NOT NULL;

BEGIN
    --  PARENT ""BRANCHES"" MUST EXIST WHEN INSERTING A CHILD IN ""PROJECT_ACCESS_PERMISSIONS""
    IF :NEW."PROJECT_ID" IS NOT NULL AND
       :NEW."BRANCH_ID" IS NOT NULL THEN
       OPEN  CPK1_"PROJECT_ACCESS_PERMISSIO(:NEW."PROJECT_ID",
                      :NEW."BRANCH_ID");
       FETCH CPK1_"PROJECT_ACCESS_PERMISSIO INTO DUMMY;
       FOUND := CPK1_"PROJECT_ACCESS_PERMISSIO%FOUND;
       close CPK1_"PROJECT_ACCESS_PERMISSIO;
       if not found then
          errno  := -20002;
          errmsg := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT CREATE CHILD IN ""PROJECT_ACCESS_PERMISSIONS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""USERS"" must exist when inserting a child in ""PROJECT_ACCESS_PERMISSIONS""
    if :new."USER_NAME" is not null then
       open  CPK2_"PROJECT_ACCESS_PERMISSIO(:new."USER_NAME");
       fetch CPK2_"PROJECT_ACCESS_PERMISSIO into dummy;
       found := CPK2_"PROJECT_ACCESS_PERMISSIO%FOUND;
       CLOSE CPK2_"PROJECT_ACCESS_PERMISSIO;
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""USERS"". CANNOT CREATE CHILD IN ""PROJECT_ACCESS_PERMISSIONS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE TRIGGER "TUB_PROJECT_ACCESS_PERMISSIONS" BEFORE UPDATE
OF "PROJECT_ID",
   "BRANCH_ID",
   "USER_NAME"
ON "PROJECT_ACCESS_PERMISSIONS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    SEQ NUMBER;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""BRANCHES""
    CURSOR CPK1_"PROJECT_ACCESS_PERMISSIO(VAR_"PROJECT_ID" INTEGER,
                    VAR_"BRANCH_ID" INTEGER) IS
       SELECT 1
       FROM   "BRANCHES"
       WHERE  "PROJECT_ID" = VAR_"PROJECT_ID"
        AND   "BRANCH_ID" = VAR_"BRANCH_ID"
        AND   VAR_"PROJECT_ID" IS NOT NULL
        AND   VAR_"BRANCH_ID" IS NOT NULL;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""USERS""
    CURSOR CPK2_"PROJECT_ACCESS_PERMISSIO(VAR_"USER_NAME" VARCHAR) IS
       SELECT 1
       FROM   "USERS"
       WHERE  "USER_NAME" = VAR_"USER_NAME"
        AND   VAR_"USER_NAME" IS NOT NULL;

BEGIN
    SEQ := INTEGRITYPACKAGE.GETNESTLEVEL;
    --  PARENT ""BRANCHES"" MUST EXIST WHEN UPDATING A CHILD IN ""PROJECT_ACCESS_PERMISSIONS""
    IF (:NEW."PROJECT_ID" IS NOT NULL) AND
       (:NEW."BRANCH_ID" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK1_"PROJECT_ACCESS_PERMISSIO(:NEW."PROJECT_ID",
                      :NEW."BRANCH_ID");
       FETCH CPK1_"PROJECT_ACCESS_PERMISSIO INTO DUMMY;
       FOUND := CPK1_"PROJECT_ACCESS_PERMISSIO%FOUND;
       close CPK1_"PROJECT_ACCESS_PERMISSIO;
       if not found then
          errno  := -20003;
          errmsg := 'PARENT DOES NOT EXIST IN ""BRANCHES"". CANNOT UPDATE CHILD IN ""PROJECT_ACCESS_PERMISSIONS"".';
          raise integrity_error;
       end if;
    end if;

    --  Parent ""USERS"" must exist when updating a child in ""PROJECT_ACCESS_PERMISSIONS""
    if (:new."USER_NAME" is not null) and (seq = 0) then
       open  CPK2_"PROJECT_ACCESS_PERMISSIO(:new."USER_NAME");
       fetch CPK2_"PROJECT_ACCESS_PERMISSIO into dummy;
       found := CPK2_"PROJECT_ACCESS_PERMISSIO%FOUND;
       CLOSE CPK2_"PROJECT_ACCESS_PERMISSIO;
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""USERS"". CANNOT UPDATE CHILD IN ""PROJECT_ACCESS_PERMISSIONS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_PROJECTS"
FOR DELETE ON "PROJECTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_PROJECTS"
FOR INSERT ON "PROJECTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_PROJECTS"
FOR UPDATE ON "PROJECTS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TDA_PROJECTS" AFTER DELETE
ON "PROJECTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;

BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  DELETE ALL CHILDREN IN ""BRANCHES""
    DELETE "BRANCHES"
    WHERE  "PROJECT_ID" = :OLD."PROJECT_ID";

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TIB_PROJECTS" BEFORE INSERT
ON "PROJECTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    --  DECLARATION OF INSERTCHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""USERS""
    CURSOR CPK1_"PROJECTS"(VAR_"USER_NAME" VARCHAR) IS
       SELECT 1
       FROM   "USERS"
       WHERE  "USER_NAME" = VAR_"USER_NAME"
        AND   VAR_"USER_NAME" IS NOT NULL;

BEGIN
    --  PARENT ""USERS"" MUST EXIST WHEN INSERTING A CHILD IN ""PROJECTS""
    IF :NEW."USER_NAME" IS NOT NULL THEN
       OPEN  CPK1_"PROJECTS"(:NEW."USER_NAME");
       FETCH CPK1_"PROJECTS" INTO DUMMY;
       FOUND := CPK1_"PROJECTS"%FOUND;
       CLOSE CPK1_"PROJECTS";
       IF NOT FOUND THEN
          ERRNO  := -20002;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""USERS"". CANNOT CREATE CHILD IN ""PROJECTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE TRIGGER "TUA_PROJECTS" AFTER UPDATE
OF "PROJECT_ID",
   "USER_NAME"
ON "PROJECTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  MODIFY PARENT CODE OF ""PROJECTS"" FOR ALL CHILDREN IN ""BRANCHES""
    IF (UPDATING('PROJECT_ID') AND :OLD."PROJECT_ID" != :NEW."PROJECT_ID") THEN
       UPDATE "BRANCHES"
        SET   "PROJECT_ID" = :NEW."PROJECT_ID"
       WHERE  "PROJECT_ID" = :OLD."PROJECT_ID";
    END IF;

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TUB_PROJECTS" BEFORE UPDATE
OF "PROJECT_ID",
   "USER_NAME"
ON "PROJECTS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
    SEQ NUMBER;
    --  DECLARATION OF UPDATECHILDPARENTEXIST CONSTRAINT FOR THE PARENT ""USERS""
    CURSOR CPK1_"PROJECTS"(VAR_"USER_NAME" VARCHAR) IS
       SELECT 1
       FROM   "USERS"
       WHERE  "USER_NAME" = VAR_"USER_NAME"
        AND   VAR_"USER_NAME" IS NOT NULL;

BEGIN
    SEQ := INTEGRITYPACKAGE.GETNESTLEVEL;
    --  PARENT ""USERS"" MUST EXIST WHEN UPDATING A CHILD IN ""PROJECTS""
    IF (:NEW."USER_NAME" IS NOT NULL) AND (SEQ = 0) THEN
       OPEN  CPK1_"PROJECTS"(:NEW."USER_NAME");
       FETCH CPK1_"PROJECTS" INTO DUMMY;
       FOUND := CPK1_"PROJECTS"%FOUND;
       CLOSE CPK1_"PROJECTS";
       IF NOT FOUND THEN
          ERRNO  := -20003;
          ERRMSG := 'PARENT DOES NOT EXIST IN ""USERS"". CANNOT UPDATE CHILD IN ""PROJECTS"".';
          RAISE INTEGRITY_ERROR;
       END IF;
    END IF;


--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
END;
/


CREATE OR REPLACE TRIGGER "COMPOUNDDELETETRIGGER_USERS"
FOR DELETE ON "USERS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDINSERTTRIGGER_USERS"
FOR INSERT ON "USERS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE OR REPLACE TRIGGER "COMPOUNDUPDATETRIGGER_USERS"
FOR UPDATE ON "USERS" COMPOUND TRIGGER
// DECLARATION
// BODY
  BEFORE STATEMENT IS
  BEGIN
     NULL;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
     NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
     NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
     NULL;
  END AFTER STATEMENT;

END
/


CREATE TRIGGER "TDA_USERS" AFTER DELETE
ON "USERS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;

BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  DELETE ALL CHILDREN IN ""PROJECT_ACCESS_PERMISSIONS""
    DELETE "PROJECT_ACCESS_PERMISSIONS"
    WHERE  "USER_NAME" = :OLD."USER_NAME";

    --  DELETE ALL CHILDREN IN ""PROJECTS""
    DELETE "PROJECTS"
    WHERE  "USER_NAME" = :OLD."USER_NAME";

    --  DELETE ALL CHILDREN IN ""COMMITS""
    DELETE "COMMITS"
    WHERE  "USER_NAME" = :OLD."USER_NAME";

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/


CREATE TRIGGER "TUA_USERS" AFTER UPDATE
OF "USER_NAME"
ON "USERS" FOR EACH ROW
DECLARE
    INTEGRITY_ERROR  EXCEPTION;
    ERRNO            INTEGER;
    ERRMSG           CHAR(200);
    DUMMY            INTEGER;
    FOUND            BOOLEAN;
BEGIN
    INTEGRITYPACKAGE.NEXTNESTLEVEL;
    --  MODIFY PARENT CODE OF ""USERS"" FOR ALL CHILDREN IN ""PROJECT_ACCESS_PERMISSIONS""
    IF (UPDATING('USER_NAME') AND :OLD."USER_NAME" != :NEW."USER_NAME") THEN
       UPDATE "PROJECT_ACCESS_PERMISSIONS"
        SET   "USER_NAME" = :NEW."USER_NAME"
       WHERE  "USER_NAME" = :OLD."USER_NAME";
    END IF;

    --  MODIFY PARENT CODE OF ""USERS"" FOR ALL CHILDREN IN ""PROJECTS""
    IF (UPDATING('USER_NAME') AND :OLD."USER_NAME" != :NEW."USER_NAME") THEN
       UPDATE "PROJECTS"
        SET   "USER_NAME" = :NEW."USER_NAME"
       WHERE  "USER_NAME" = :OLD."USER_NAME";
    END IF;

    --  MODIFY PARENT CODE OF ""USERS"" FOR ALL CHILDREN IN ""COMMITS""
    IF (UPDATING('USER_NAME') AND :OLD."USER_NAME" != :NEW."USER_NAME") THEN
       UPDATE "COMMITS"
        SET   "USER_NAME" = :NEW."USER_NAME"
       WHERE  "USER_NAME" = :OLD."USER_NAME";
    END IF;

    INTEGRITYPACKAGE.PREVIOUSNESTLEVEL;

--  ERRORS HANDLING
EXCEPTION
    WHEN INTEGRITY_ERROR THEN
       BEGIN
       INTEGRITYPACKAGE.INITNESTLEVEL;
       RAISE_APPLICATION_ERROR(ERRNO, ERRMSG);
       END;
END;
/

